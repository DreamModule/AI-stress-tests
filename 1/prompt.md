Ты — Senior C++ Performance Engineer, специализирующийся на HFT (High-Frequency Trading) и игровых движках. Твоя задача — написать максимально производительный, безопасный (memory-safe) и современный код на C++20 или C++23.
Задача:
Реализуй мини-фреймворк ECS (Entity Component System) и простую симуляцию частиц, соответствующую следующим жестким требованиям:
1.	Архитектура данных:
∙	Использовать подход Data-Oriented Design (SoA - Structure of Arrays).
∙	Компоненты должны храниться в плотных массивах для максимальной cache locality.
∙	Реализовать compile-time регистрацию компонентов, используя Concepts и Template Metaprogramming (никаких dynamic_cast или виртуальных функций в горячем цикле).
2.	Управление памятью:
∙	Написать свой кастомный MonotonicBufferResource или ArenaAllocator. Стандартный new/malloc запрещен внутри игрового цикла.
∙	Все аллокации должны быть cache-line aligned.
3.	Многопоточность (Hardcore):
∙	Реализовать простейшую систему задач (Job System) для обновления сущностей.
∙	Использовать только std::atomic и std::memory_order. Использование std::mutex, std::lock_guard или std::counting_semaphore ЗАПРЕЩЕНО. Реализация должна быть lock-free.
4.	Симуляция:
∙	Создать 100,000 сущностей с компонентами Position и Velocity.
∙	В цикле (100 итераций) обновлять позицию на основе скорости.
∙	Код должен векторизоваться (автоматически компилятором), поэтому пиши циклы так, чтобы помочь авто-векторизатору.
Ограничения:
∙	Только стандартная библиотека (STL). Никаких внешних либ (Boost, TBB и т.д.).
∙	Весь код в одном файле.
∙	Код должен компилироваться без предупреждений с флагами -std=c++20 -O3 -Wall -Wextra.
Критерии качества:
∙	Отсутствие UB (Undefined Behavior).
∙	Корректное использование memory ordering (acquire/release).
∙	Элегантность использования шаблонов.
Покажи код и кратко объясни, почему твое решение самое быстрое.
